<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MicroMagnetic.jl</title><meta name="title" content="API · MicroMagnetic.jl"/><meta property="og:title" content="API · MicroMagnetic.jl"/><meta property="twitter:title" content="API · MicroMagnetic.jl"/><meta name="description" content="Documentation for MicroMagnetic.jl."/><meta property="og:description" content="Documentation for MicroMagnetic.jl."/><meta property="twitter:description" content="Documentation for MicroMagnetic.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MicroMagnetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Micromagnetics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/micromagnetics/compute_energy/">Calculating micromagnetic energies</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/nanobar/">Magnetization state of a nanobar</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/vortex/">Magnetic vortex</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std4/">Micromagnetic Standard Problem 4</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/std5/">Micromagnetic Standard Problem 5</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/skyrmion_stt/">Skyrmion dynamics under spin transfer torques</a></li><li><a class="tocitem" href="../tutorials/micromagnetics/stoner_wohlfarth/">Stoner–Wohlfarth model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Atomistic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/atomistic/skyrmion/">Magnetic skyrmion</a></li><li><a class="tocitem" href="../tutorials/atomistic/skyrmion_afm/">Antiferromagnetic skyrmion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Monte carlo</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/monte_carlo/M_T_curve/">M-T curve using Monte Carlo</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Neb</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/neb/neb_skx/">Skyrmion collapse using NEB</a></li></ul></li></ul></li><li><a class="tocitem" href="../equations/">Equations</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Shapes"><span>Shapes</span></a></li><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li><li><a class="tocitem" href="#DataSaving"><span>DataSaving</span></a></li><li><a class="tocitem" href="#Tools"><span>Tools</span></a></li><li><a class="tocitem" href="#DataTypes"><span>DataTypes</span></a></li><li><a class="tocitem" href="#Others"><span>Others</span></a></li></ul></li><li><a class="tocitem" href="../developer/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ww1g11/MicroMagnetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.FDMesh" href="#MicroMagnetic.FDMesh"><code>MicroMagnetic.FDMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a FDMesh for given parameters. <code>pbc</code> could be any combination of &quot;x&quot;, &quot;y&quot; and &quot;z&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/mesh.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.CubicMesh" href="#MicroMagnetic.CubicMesh"><code>MicroMagnetic.CubicMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CubicMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a simple cubic mesh, in which each cell is only connected to six nearest neighbors  and forming a simple cube structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/mesh.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.TriangularMesh" href="#MicroMagnetic.TriangularMesh"><code>MicroMagnetic.TriangularMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TriangularMesh(; dx=1e-9, nx=1, ny=1, pbc=&quot;open&quot;)</code></pre><p>Create a 2d triangular mesh. The index of the nearest neighbours and the next-nearest  neighbours are given as follows:</p><table><tr><th style="text-align: center">nearest index</th><th style="text-align: center">location</th><th style="text-align: center">next-nearest index</th><th style="text-align: center">location</th></tr><tr><td style="text-align: center">1</td><td style="text-align: center">right</td><td style="text-align: center">1</td><td style="text-align: center">top-right</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">top-right</td><td style="text-align: center">2</td><td style="text-align: center">top</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">top-left</td><td style="text-align: center">3</td><td style="text-align: center">top-left</td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">left</td><td style="text-align: center">4</td><td style="text-align: center">bottom-left</td></tr><tr><td style="text-align: center">5</td><td style="text-align: center">bottom-left</td><td style="text-align: center">5</td><td style="text-align: center">bottom</td></tr><tr><td style="text-align: center">6</td><td style="text-align: center">bottom-right</td><td style="text-align: center">6</td><td style="text-align: center">bottom-right</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/mesh.jl#L22-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.CylindricalTubeMesh" href="#MicroMagnetic.CylindricalTubeMesh"><code>MicroMagnetic.CylindricalTubeMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CylindricalTubeMesh(;dz=1e-9, R=20e-9, nz=1, nr=10, pbc=&quot;open&quot;)</code></pre><p>Create a cylindrical tube mesh along the +z direction. </p><p>The spins are located on the cylindrical tube uniformly, and are indexed as follows:</p><pre><code class="language-julia hljs">  id = index(i, 1, k, nr, 1, nz)</code></pre><p>which means that the spins are labelled in a ring firstly, then <code>nz</code> is the number of rings.   The coordinates of the spins at each ring are given as <code>(R cos(2*pi*(i-1)/nr), R sin(2*pi*(nr-1)/nr))</code>.</p><p>The nearest neighbours are indexed as follows:</p><p>|  1      2        3       4            |left   right    bottom   top |</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/mesh.jl#L280-L296">source</a></section></article><h2 id="Shapes"><a class="docs-heading-anchor" href="#Shapes">Shapes</a><a id="Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Shapes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Cylinder" href="#MicroMagnetic.Cylinder"><code>MicroMagnetic.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cylinder(;center = (0.0, 0.0, 0.0), radius = 1.0, height= Inf, normal = (0.0, 0.0, 1.0))</code></pre><p>Create a Cylinder shape. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/csg.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Box" href="#MicroMagnetic.Box"><code>MicroMagnetic.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box(;center::Tuple=(0.0, 0.0, 0.0), sides::Tuple=(1.0,1.0,1.0), theta=0.0)</code></pre><p>Create a Box shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/csg.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Torus" href="#MicroMagnetic.Torus"><code>MicroMagnetic.Torus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Torus(; center::Tuple=(0.0, 0.0, 0.0), R=1.0, r=0.2)</code></pre><p>Create a Torus shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/csg.jl#L70-L74">source</a></section></article><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_backend" href="#MicroMagnetic.set_backend"><code>MicroMagnetic.set_backend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_backend(backend=&quot;cuda&quot;)</code></pre><p>Set the backend of MicroMagnetic. This function allows you to specify the backend for MicroMagnetic simulations.  The available options and their corresponding hardware and backends are shown below:</p><table><tr><th style="text-align: left">Option</th><th style="text-align: left">Hardware</th><th style="text-align: left">Backend</th></tr><tr><td style="text-align: left">&quot;cpu&quot;</td><td style="text-align: left">CPU</td><td style="text-align: left"><code>KernelAbstractions.CPU()</code></td></tr><tr><td style="text-align: left">&quot;cuda&quot; or &quot;nvidia&quot;</td><td style="text-align: left">NVIDIA GPU</td><td style="text-align: left"><code>CUDA.CUDABackend()</code></td></tr><tr><td style="text-align: left">&quot;amd&quot; or &quot;roc&quot;</td><td style="text-align: left">AMD GPU</td><td style="text-align: left"><code>AMDGPU.ROCBackend()</code></td></tr><tr><td style="text-align: left">&quot;oneAPI&quot; or &quot;intel&quot;</td><td style="text-align: left">Intel GPU</td><td style="text-align: left"><code>oneAPI.oneAPIBackend()</code></td></tr><tr><td style="text-align: left">&quot;metal&quot;  or &quot;apple&quot;</td><td style="text-align: left">Apple GPU</td><td style="text-align: left"><code>Metal.MetalBackend()</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/MicroMagnetic.jl#L54-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_precision" href="#MicroMagnetic.set_precision"><code>MicroMagnetic.set_precision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_precision(x::Type{&lt;:AbstractFloat}=Float64)</code></pre><p>Set the precision for MicroMagnetic simulations.</p><p>This function allows you to specify the precision of floating-point numbers to be used in MicroMagnetic simulations.  By default, it sets the precision to <code>Float64</code>. If single-precision computation is required, you can specify <code>Float32</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_precision(Float32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/MicroMagnetic.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.Sim" href="#MicroMagnetic.Sim"><code>MicroMagnetic.Sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Sim(mesh::Mesh; driver=&quot;LLG&quot;, name=&quot;dyn&quot;, integrator=&quot;DormandPrince&quot;)</code></pre><p>Create a simulation instance for given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.create_sim" href="#MicroMagnetic.create_sim"><code>MicroMagnetic.create_sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_sim(mesh; args...)</code></pre><p>Create a micromagnetic simulation instance with given arguments. </p><ul><li><code>mesh</code>: a mesh has to be provided to start the simulation. The mesh could be <a href="#MicroMagnetic.FDMesh"><code>FDMesh</code></a>, <a href="#MicroMagnetic.CubicMesh"><code>CubicMesh</code></a>, or <a href="#MicroMagnetic.TriangularMesh"><code>TriangularMesh</code></a>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>name</code> : the simulation name, should be a string.</li><li><code>driver</code> : the driver name, should be a string. By default, the driver is &quot;SD&quot;.</li><li><code>alpha</code> : the Gilbert damping in the LLG equation, should be a number.</li><li><code>beta</code> : the nonadiabatic strength in the LLG equation with spin transfer torques (zhang-li model), should be a number.</li><li><code>gamma</code> : the gyromagnetic ratio, default value = 2.21e5.</li><li><code>ux</code>, <code>uy</code> or <code>uz</code>: the strengths of the spin transfer torque.</li><li><code>ufun</code> : the time-dependent function for <code>u</code>. </li><li><code>Ms</code>: the saturation magnetization, should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. By default, Ms=8e5</li><li><code>mu_s</code>: the magnetic moment, should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>. By default, mu<em>s=2*mu</em>B</li><li><code>A</code> or <code>J</code>: the exchange constant, should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>D</code> : the DMI constant, should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>dmi_type</code> : the type of DMI, could be &quot;bulk&quot; or &quot;interfacial&quot;.</li><li><code>Ku</code>: the anisotropy constant, should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>axis</code>: the anisotropy axis, should be a tuple, such as (0,0, 1)</li><li><code>demag</code> : include demagnetization or not, should be a boolean, i.e., true or false. By default,  demag=false.</li><li><code>H</code>: the external field, should be a tuple or function, i.e., <a href="#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>. </li><li><code>m0</code> : the initial magnetization, should be a tuple or function, i.e., <a href="#MicroMagnetic.TupleOrArrayOrFunction"><code>TupleOrArrayOrFunction</code></a>. </li><li><code>T</code> : the temperature, should be should be <a href="#MicroMagnetic.NumberOrArrayOrFunction"><code>NumberOrArrayOrFunction</code></a>.</li><li><code>shape</code> : the shape defines the geometry of the sample, where parameters are configured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L467-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.NEB" href="#MicroMagnetic.NEB"><code>MicroMagnetic.NEB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NEB(sim::AbstractSim, init_images::TupleOrArray, frames_between_images::TupleOrArray; 
    name=&quot;NEB&quot;, spring_constant=1.0e5, driver=&quot;LLG&quot;, clib_image=-1)</code></pre><p>Create a NEB instance.</p><p><strong>Arguments</strong></p><ul><li><code>sim::AbstractSim</code>: Simulation instance that includes the interactions.</li><li><code>init_images::TupleOrArray</code>: Tuple or array of initial and final state images. Intermediate state images can also be included.</li><li><code>frames_between_images::TupleOrArray</code>: Tuple or array specifying the number of frames between each pair of images.</li><li><code>name::String=&quot;NEB&quot;</code>: Name for the NEB instance.</li><li><code>spring_constant::Float64=1.0e5</code>: Spring constant used in the NEB simulation.</li><li><code>driver::String=&quot;LLG&quot;</code>: Driver for the NEB simulation. Options are <code>&quot;SD&quot;</code> or <code>&quot;LLG&quot;</code>.</li><li><code>clib_image::Int=-1</code>: Optional parameter for specifying a particular image in the library (default is -1).</li></ul><p><strong>Returns</strong></p><p>A NEB instance configured with the provided parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># define mesh and the corresponding parameters
mesh = FDMesh(nx=60, ny=60, nz=1, dx=2e-9, dy=2e-9, dz=2e-9, pbc=&quot;xy&quot;)
params = Dict(
    :Ms =&gt; 3.84e5,
    :A =&gt; 3.25e-12,
    :D =&gt; 5.83e-4,
    :H =&gt; (0, 0, 120 * mT)
)

# Define the initial and final state, stored in the init_images list.
# Any acceptable object, such as a function, a tuple, or an array, can be used.
# The init_images list can also contain the intermediate state if you have one.
init_images = [read_vtk(&quot;skx.vts&quot;), (0, 0, 1)]

# Define the interpolation array to specify the number of images used in the NEB simulation.
# The length of the interpolation array should be the length of init_images minus one.
# For example, if init_images = [read_vtk(&quot;skx.vts&quot;), read_vtk(&quot;skx2.vts&quot;), (0, 0, 1)], 
# the length of interpolation should be 2, i.e., something like interpolation = [5,5].
interpolation = [6]

# Use the create_sim method to create a Sim instance.
sim = create_sim(mesh; params...)

# Create the NEB instance and set the spring_constant. The driver can be &quot;SD&quot; or &quot;LLG&quot;.
neb = NEB(sim, init_images, interpolation; name=&quot;skx_fm&quot;, driver=&quot;SD&quot;)
# neb.spring_constant = 1e7

# Relax the entire system.
relax(neb; stopping_dmdt=0.1, save_vtk_every=1000, maxsteps=5000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/neb/neb.jl#L31-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.run_sim" href="#MicroMagnetic.run_sim"><code>MicroMagnetic.run_sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_sim(sim::AbstractSim; steps=10, dt=1e-12, save_data=true, save_m_every=1, saver=nothing)</code></pre><p>Run the simulation to the time <code>steps*dt</code>.</p><ul><li><code>steps</code> : the total steps of the simulation</li><li><code>dt</code><code>: the time interval of each step, so the total simulation time is</code>steps*dt`</li><li><code>save_data</code> : saving the overall data such as energies and average magnetization of the simulation at each step</li><li><code>save_m_every</code> : save magnetization for every <code>save_m_every</code> step, a negative save<em>m</em>every will disable the magnetization saving.</li><li><code>saver</code> : a saver struct, by default it will use sim&#39;s saver. But you can use customized saver instead. For example, if we want to compute the guiding</li></ul><p>center and save it to a text file, we can define the following saver</p><pre><code class="language-julia hljs">    customized_saver = init_saver(&quot;output.txt&quot;, &quot;LLG&quot;)
    push!(custom_saver.items, SaverItem(&quot;center&quot;, &quot;m&quot;, compute_guiding_center))
    run_sim(sim, saver=customized_saver)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L594-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_Ms" href="#MicroMagnetic.set_Ms"><code>MicroMagnetic.set_Ms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)</code></pre><p>Set the saturation magnetization Ms of the studied system. For example,</p><pre><code class="language-julia hljs">   set_Ms(sim, 8.6e5)</code></pre><p>or</p><pre><code class="language-julia hljs">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end
set_Ms(sim, circular_Ms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L51-L70">source</a></section><section><div><pre><code class="language-julia hljs">set_Ms(sim::AbstractSim, geo::Shape, Ms::Number)</code></pre><p>Set the saturation magnetization Ms within the Shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_driver" href="#MicroMagnetic.set_driver"><code>MicroMagnetic.set_driver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_driver(sim::AbstractSim, args::Dict)</code></pre><p>Set the driver of the simulation. This function is not intended for users but for developers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L197-L201">source</a></section><section><div><pre><code class="language-julia hljs">set_driver(sim::AbstractSim; driver=&quot;LLG&quot;, integrator=&quot;DormandPrince&quot;, args...)</code></pre><p>Set the driver of the simulation, can be used to switch the driver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.set_mu_s" href="#MicroMagnetic.set_mu_s"><code>MicroMagnetic.set_mu_s</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_mu_s(sim::AtomisticSim, Ms::NumberOrArrayOrFunction)</code></pre><p>Set magnetic moment mu_s of the studied system. For example,</p><pre><code class="language-julia hljs">   set_mu_s(sim, 2*mu_B)</code></pre><p>or</p><pre><code class="language-julia hljs">function circular_shape(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 2*mu_B
    end
    return 0.0
end
set_mu_s(sim, circular_shape)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/sim.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0" href="#MicroMagnetic.init_m0"><code>MicroMagnetic.init_m0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)</code></pre><p>Set the initial magnetization of the system. If <code>norm=false</code> the magnetization array will be not normalised. Examples:</p><pre><code class="language-julia hljs">   init_m0(sim, (1,1,1))</code></pre><p>or</p><pre><code class="language-julia hljs">   init_m0(sim, (1,1,1), norm=false)</code></pre><p>or</p><pre><code class="language-julia hljs">   function uniform_m0(i,j,k,dx,dy,dz)
       return (0,0,1)
   end
   init_m0(sim, uniform_m0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L149-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0_random" href="#MicroMagnetic.init_m0_random"><code>MicroMagnetic.init_m0_random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_m0_random(sim::MicroSim)</code></pre><p>Set the initial magnetization with random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/init_m.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.init_m0_skyrmion" href="#MicroMagnetic.init_m0_skyrmion"><code>MicroMagnetic.init_m0_skyrmion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_m0_skyrmion(sim::AbstractSim, center::Tuple, R::Float64; ratio=0.7, p=-1, c=1, type=&quot;B&quot;)</code></pre><p>Set the magnetization with skyrmions. Note that this function can be called mulitple times to add more skyrmons.</p><p>center :  the skyrmion center, should be a Tuple. For example, center = (50e-9,50e-9)</p><p>R : the skyrmion radius.</p><p>ratio : ratio=w/R where w is the width of domain wall. By default ratio = 0.7</p><p>p : polarity, +1 –&gt; core up; -1 –&gt; core down</p><p>c : chirality, +1 –&gt; lefthand,for positive D; -1 –&gt; righthand,for negative D</p><p>type : &quot;B&quot; or &quot;N&quot;, representing Bloch or Neel skyrmions.</p><p>For example:</p><pre><code class="language-julia hljs">    init_m0_skyrmion(sim, (50e-9,50e-9), 2e-8, ratio=0.5, p=-1, c=1, type=&quot;B&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/init_m.jl#L25-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch" href="#MicroMagnetic.add_exch"><code>MicroMagnetic.add_exch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_exch(sim::MicroSim, A::NumberOrTupleOrArrayOrFunction; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system. The exchange energy is definded as </p><p class="math-container">\[  E_\mathrm{ex} = \int_{V} A (\nabla \mathbf{m})^2 \mathrm{d}V\]</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">    add_exch(sim, 1e-11)</code></pre><p>or </p><pre><code class="language-julia hljs">    add_exch(sim, (2e-12,5e-12,0))</code></pre><p>or</p><pre><code class="language-julia hljs">    function spatial_A(i,j,k,dx,dy,dz)
        if i&lt;10
            return 1e-11
        else
            return 2e-11
        end
    end
    add_exch(sim, spatial_A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L128-L160">source</a></section><section><div><pre><code class="language-julia hljs">add_exch(sim::AbstractSim, geo::Shape, A::Number; name=&quot;exch&quot;)</code></pre><p>Add exchange interaction within the Shape, or update corresponding A if other exch is added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L267-L272">source</a></section><section><div><pre><code class="language-julia hljs">add_exch(sim::AtomisticSim, J::NumberOrArray; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system. The length of J should be equal to the length of neigbours.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/sim.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_anis" href="#MicroMagnetic.add_anis"><code>MicroMagnetic.add_anis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy to the system, where the energy density is given by</p><p class="math-container">\[    E_\mathrm{anis} =  K_{u} (1 - \vec{m} \cdot \hat{u})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L324-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_cubic_anis" href="#MicroMagnetic.add_cubic_anis"><code>MicroMagnetic.add_cubic_anis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_cubic_anis(sim::AbstractSim, Kc::Float64; axis1=(1,0,0), axis2=(0,1,0), name=&quot;cubic&quot;)</code></pre><p>add a cubic anisotropy with default axis (1,0,0) , (0,1,0), and (0,0,1). The third axis is defined as axis3 = axis1 x axis2.</p><p class="math-container">\[  E_\mathrm{cubic} = -\int_{V} K_c (m_x^4 + m_y^4 + m_z^4) \, dV\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">    add_cubic_anis(sim, 1e3, (1, 1, 0), (1, -1, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L422-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi" href="#MicroMagnetic.add_dmi"><code>MicroMagnetic.add_dmi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_dmi(sim::MicroSim, D::NumberOrTupleOrArrayOrFunction; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add DMI to the system. <code>type</code> could be &quot;bulk&quot;, &quot;interfacial&quot; or &quot;D2d&quot;. </p><p>Examples:</p><pre><code class="language-julia hljs">   add_dmi(sim, 1e-3, type=&quot;interfacial&quot;)</code></pre><p>or</p><pre><code class="language-julia hljs">   add_dmi(sim, 1e-3, type=&quot;D2d&quot;)</code></pre><pre><code class="language-julia hljs">   add_dmi(sim, (1e-3, 1e-3, 0), type=&quot;bulk&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L193-L213">source</a></section><section><div><pre><code class="language-julia hljs">add_dmi(sim::AtomisticSim, D::Real; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add bulk dmi energy to the system. The DMI is defined as</p><p class="math-container">\[\mathcal{H}_\mathrm{dmi} = \sum_{\langle i, j\rangle}  \mathbf{D}_{i j} \cdot\left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right)\]</p><p>where <span>$\mathbf{D}_{i j}$</span> is the DM vector. For the bulk dmi <span>$\mathbf{D}_{i j} = D \hat{r}_{ij}$</span> and for interfacial dmi  <span>$\mathbf{D}_{i j} = D \hat{r}_{ij} \times \hat{z}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/sim.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_demag" href="#MicroMagnetic.add_demag"><code>MicroMagnetic.add_demag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_demag(sim::MicroSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0, fft=true)</code></pre><p>Add Demag to the system. <code>Nx</code>, <code>Ny</code> and <code>Nz</code> can be used to describe the macro boundary conditions which means that the given mesh is repeated <code>2Nx+1</code>, <code>2Ny+1 and</code>2Nz+1<code>times in</code>x<code>,</code>y<code>and</code>z` direction, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L300-L305">source</a></section><section><div><pre><code class="language-julia hljs">add_demag(sim::AtomisticSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0 )</code></pre><p>add dipolar interaction into the system.</p><p class="math-container">\[\mathcal{H}_{\mathrm{d}}=-\frac{\mu_0 \mu_s^2}{4 \pi} \sum_{i&lt;j} \frac{3\left(\mathbf{m}_i \cdot \hat{\mathbf{r}}_{i j}\right)\left(\mathbf{m}_j \cdot \hat{\mathbf{r}}_{i j}\right)-\mathbf{m}_i \cdot \mathbf{m}_j}{r_{i j}^3}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/sim.jl#L336-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_zeeman" href="#MicroMagnetic.add_zeeman"><code>MicroMagnetic.add_zeeman</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Add a static Zeeman energy to the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L4-L8">source</a></section><section><div><pre><code class="language-julia hljs">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=&quot;timezeeman&quot;)</code></pre><p>Add a time varying zeeman to system.</p><p>The input <code>ft</code> is a function of time <code>t</code> and its return value should be a tuple with length 3.</p><p>Example:</p><pre><code class="language-julia hljs">  function time_fun(t)
    w = 2*pi*2.0e9
    return (sin(w*t), cos(w*t), 0)
  end

  function spatial_H(i, j, k, dx, dy, dz)
    H = 1e3
    if i&lt;=2
        return (H, H, 0)
    end
    return (0, 0, 0)
  end

  add_zeeman(sim, spatial_H, time_fun)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L72-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_exch_int" href="#MicroMagnetic.add_exch_int"><code>MicroMagnetic.add_exch_int</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_exch_int(sim::AbstractSim, J::Float64; k1=1, k2=-1, name=&quot;rkky&quot;)</code></pre><p>Add an RKKY-type exchange for interlayers. The energy of RKKY-type exchange is defined as </p><p class="math-container">\[E_\mathrm{rkky} =  - \int_\Gamma J_\mathrm{rkky} \mathbf{m}_{i} \cdot \mathbf{m}_{j} dA\]</p><p>where <span>$\Gamma$</span> is the interface between two layers with magnetizations <span>$\mathbf{m}_{i}$</span> and <span>$\mathbf{m}_{j}$</span>, <span>$J_\mathrm{rkky}$</span> is the coupling constant which is related to the spacer layer thickness. </p><p>The effective field is given then as</p><p class="math-container">\[\mathbf{H}_i = \frac{1}{\mu_0 M_s}  \frac{J_\mathrm{rkky}}{\Delta_z} \mathbf{m}_{j} \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L511-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.add_dmi_int" href="#MicroMagnetic.add_dmi_int"><code>MicroMagnetic.add_dmi_int</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_dmi_int(sim::MicroSimGPU, D::Tuple{Real, Real, Real}; k1=1, k2=-1, name=&quot;dmi_int&quot;)</code></pre><p>Add an interlayer DMI to the system. The energy of interlayer DMI is defined as </p><p class="math-container">\[E_\mathrm{dmi-int} =  \int_\Gamma \mathbf{D} \cdot \left(\mathbf{m}_{i} \times \mathbf{m}_{j}\right) dA\]</p><p>where <span>$\Gamma$</span> is the interface between two layers with magnetizations <span>$\mathbf{m}_{i}$</span> and <span>$\mathbf{m}_{j}$</span>.  <span>$\mathbf{D}$</span> is the effective DMI vector. </p><p>The effective field is given</p><p class="math-container">\[\mathbf{H}_i = \frac{1}{\mu_0 M_s \Delta_z}  \mathbf{D} \times \mathbf{m}_{j} \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L548-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.update_zeeman" href="#MicroMagnetic.update_zeeman"><code>MicroMagnetic.update_zeeman</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Set the Zeeman field to H0 where H0 is TupleOrArrayOrFunction according to its name. For example,</p><pre><code class="language-julia hljs">   add_zeeman(sim, (0,0,0), name=&quot;my_H&quot;)  #create a zeeman energy with field (0,0,0) A/m
   update_zeeman(sim, (0,0,1e5), name=&quot;my_H&quot;)  #change the field to (0,0,1e5) A/m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.update_anis" href="#MicroMagnetic.update_anis"><code>MicroMagnetic.update_anis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = &quot;anis&quot;)</code></pre><p>update anisotropy constant Ku according to its name.</p><p>Example:</p><pre><code class="language-julia hljs">    mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9)
    sim = Sim(mesh)
    add_anis(sim, 3e4, axis = (0,0,1), name=&quot;K1&quot;)
    add_anis(sim, 1e5, axis = (1,0,0), name=&quot;K2&quot;)
    update_anis(sim, 5e4, name=&quot;K2&quot;)  #update anisotropy K2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/micro/add_field.jl#L395-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.relax" href="#MicroMagnetic.relax"><code>MicroMagnetic.relax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relax(sim::AbstractSim; maxsteps=10000, stopping_dmdt=0.01, save_data_every=1, save_m_every=-1, using_time_factor=true)</code></pre><p>Relax the system using <code>LLG</code> or <code>SD</code> driver. This function works for both micromagnetic and atomistic simulations.</p><p><code>maxsteps</code> is the maximum steps allowed to run. </p><p><code>stopping_dmdt</code> is the main stop condition, both for both for <code>LLG</code> and <code>SD</code> drivers. For standard micromagnetic simulaition,  the typical value of <code>stopping_dmdt</code> is in the range of [0.01, 1].  In the <code>SD</code> driver, the time is not strictly defined.  To make it comparable for the <code>LLG</code> driver, we multiply a factor of <code>gamma</code>. However, for the atomistic model  with dimensionless unit, this factor should not be used. In this situation, <code>using_time_factor</code> should be set to <code>false</code>.</p><p><code>save_data_every</code> set the step for overall data saving such as energies and average magnetization. A negative <code>save_data_every</code> will disable the data saving (<code>save_data_every=-1</code> will enable the data saving at the end of relaxing).</p><p><code>save_m_every</code> set the step for magnetization saving, a negative <code>save_m_every</code> will disable the magnetization saving.</p><p>Examples:</p><pre><code class="language-julia hljs">    relax(sim, maxsteps=10000, stopping_dmdt=0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/sim.jl#L245-L267">source</a></section></article><h2 id="DataSaving"><a class="docs-heading-anchor" href="#DataSaving">DataSaving</a><a id="DataSaving-1"></a><a class="docs-heading-anchor-permalink" href="#DataSaving" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.save_vtk" href="#MicroMagnetic.save_vtk"><code>MicroMagnetic.save_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_vtk(mesh::Mesh, shape::Union{CSGNode,Shape}, fname::String)</code></pre><p>Save the shape to vtk. </p><pre><code class="language-julia hljs">    mesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100, nz=50)
    t1 = Torus(R = 60e-9, r=20e-9)
    save_vtk(mesh, t1, &quot;torus&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/csg.jl#L198-L208">source</a></section><section><div><pre><code class="language-julia hljs">save_vtk(sim::AbstractSim, fname::String; fields::Array{String, 1} = String[])</code></pre><p>Save magnetization or other fields to vtk.</p><pre><code class="language-julia hljs">    save_vtk(sim, &quot;m&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/vtk.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.save_ovf" href="#MicroMagnetic.save_ovf"><code>MicroMagnetic.save_ovf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_ovf(sim::AbstractSim, fname::String; type::DataType = Float64)</code></pre><p>Save spins by ovf, which can be viewed by Muview. </p><p>Parameters:</p><pre><code class="nohighlight hljs">Sim : Sim struct whose spin to be saved.

fname : Save file name.</code></pre><p>Optional:</p><pre><code class="nohighlight hljs">type : Data type of ovf2 file. Can be chosen from Float32, Float64 or String.</code></pre><p>For example:</p><pre><code class="nohighlight hljs">```julia
    save_ovf(sim, &quot;ovf_example&quot;)
```</code></pre><p>Or to specify a certain data type:</p><pre><code class="nohighlight hljs">```julia
    save_ovf(sim, &quot;ovf_example&quot;, type = String)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/ovf2.jl#L17-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.read_ovf" href="#MicroMagnetic.read_ovf"><code>MicroMagnetic.read_ovf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_ovf(sim, fname)

Initialize sim with an ovf file named of &quot;fname.ovf&quot;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/ovf2.jl#L201-L205">source</a></section><section><div><pre><code class="language-julia hljs">read_ovf(fname)

Load ovf file as OVF2 Type, where spin is stored in OVF2.data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/ovf2.jl#L257-L261">source</a></section></article><h2 id="Tools"><a class="docs-heading-anchor" href="#Tools">Tools</a><a id="Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.ovf2vtk" href="#MicroMagnetic.ovf2vtk"><code>MicroMagnetic.ovf2vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ovf2vtk(ovf_name, vtk_name=nothing; point_data=false, box=noting)</code></pre><p>Convert ovf file to vtk format. The data will be saved to points if point_data == true otherwise the data will be saved to cells.</p><p>If box is not nothing, it should be a tuple. For instance, box = (nx1, nx2, ny1, ny2, nz1, nz2). In this case, the generated vtk only contains the spins inside the box (including the boundary).</p><pre><code class="language-julia hljs">    ovf2vtk(&quot;my.ovf&quot;, &quot;test.vts&quot;)
    ovf2vtk(&quot;my.ovf&quot;, point_data=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/vtk.jl#L119-L132">source</a></section></article><h2 id="DataTypes"><a class="docs-heading-anchor" href="#DataTypes">DataTypes</a><a id="DataTypes-1"></a><a class="docs-heading-anchor-permalink" href="#DataTypes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.NumberOrArrayOrFunction" href="#MicroMagnetic.NumberOrArrayOrFunction"><code>MicroMagnetic.NumberOrArrayOrFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOrArrayOrFunction</code></pre><p>In Micromagnetics, typical parameters such as saturation magnetization <code>Ms</code> and exchange stiffness constant <code>A</code> are constant. However, there are many cases that a spatial <code>Ms</code> is needed. For instance, if the simulated system is a circular disk the Ms in the corners should be set to zero. If the simulated system contains mutiple materials, the exchange constant <code>A</code> should be spatial as well. The Union <code>NumberOrArrayOrFunction</code> is designed to deal with such situations. As indicated from its name, it means that the input parameter could be a number or an array or a function:</p><ul><li><p>Number: should be Real.</p></li><li><p>Array: the length of the array should be <code>N</code> where <code>N</code> is the total spin number of the system.</p></li><li><p>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> where <code>i,j,k</code> is the cell index and <code>dx,dy,dz</code> is the cellsize. The return value of the function should be a real number. For example,</p><pre><code class="language-julia hljs">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/head.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.NumberOrTupleOrArrayOrFunction" href="#MicroMagnetic.NumberOrTupleOrArrayOrFunction"><code>MicroMagnetic.NumberOrTupleOrArrayOrFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOrTupleOrArrayOrFunction</code></pre><p>In micromagnetics, there are also cases where the input parameters can be either scalars or vectors and vary with space. For example, the parameters for the DMI could be a const for bulk DMI or interfacial DMI. In some materials, the DMI const may differ in different  directions and thus a tuple with three numbers is required. In MicroMagnetic, the union <code>NumberOrTupleOrArrayOrFunction</code> is designed to deal  with such situations. Similar to <code>NumberOrArrayOrFunction</code>, <code>NumberOrTupleOrArrayOrFunction</code> means that the input parameter could be  a number, a tuple, an array or a function:</p><ul><li><p>Number: should be Real.</p></li><li><p>Tuple: should be Real with length 3. For example, <code>(1,2e-5,0)</code>.</p></li><li><p>Array: the length of the array should be <code>N</code> or <code>3N</code> where <code>N</code> is the total spin number of the system.</p></li><li><p>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> and the return value should be a tuple with length 3.</p><p>For example,</p><pre><code class="language-julia hljs">function uniform_m0(i,j,k,dx,dy,dz)
    return (0,0,1)
end</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/head.jl#L31-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.NumberOrArray" href="#MicroMagnetic.NumberOrArray"><code>MicroMagnetic.NumberOrArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumberOrArray</code></pre><p>Similar to Union <code>NumberOrArrayOrFunction</code>, the Union <code>NumberOrArray</code> is designed to deal with cases that a number or an array is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/head.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.TupleOrArrayOrFunction" href="#MicroMagnetic.TupleOrArrayOrFunction"><code>MicroMagnetic.TupleOrArrayOrFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TupleOrArrayOrFunction</code></pre><p>Similar to <code>NumberOrArrayOrFunction</code>, <code>TupleOrArrayOrFunction</code> means that the input parameter could be a tuple or an array or a function:</p><ul><li>Tuple: should be Real with length 3. For example, <code>(0,0,1e5)</code>.</li><li>Array: the length of the array should be <code>3N</code> where <code>N</code> is the total spin number of the system.</li><li>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> and the return value should be a tuple with length 3. For example,<pre><code class="language-julia hljs">function uniform_m0(i,j,k,dx,dy,dz)
    return (0,0,1)
end</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/head.jl#L69-L83">source</a></section></article><h2 id="Others"><a class="docs-heading-anchor" href="#Others">Others</a><a id="Others-1"></a><a class="docs-heading-anchor-permalink" href="#Others" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.MicroSim" href="#MicroMagnetic.MicroSim"><code>MicroMagnetic.MicroSim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MicroSim{T&lt;:AbstractFloat} &lt;: AbstractSim</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/head.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MicroMagnetic.AtomisticSim" href="#MicroMagnetic.AtomisticSim"><code>MicroMagnetic.AtomisticSim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AtomisticSim{T&lt;:AbstractFloat} &lt;: AbstractSim</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/MicroMagnetic.jl/blob/9c38e64429737caaa3cda22edc08e84769c65d7b/src/atomistic/head.jl#L2-L4">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../equations/">« Equations</a><a class="docs-footer-nextpage" href="../developer/">Developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 16 July 2024 14:27">Tuesday 16 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
